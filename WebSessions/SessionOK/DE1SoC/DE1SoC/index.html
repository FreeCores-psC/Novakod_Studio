<html><head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DE1SoC Board Renderer (layout.json)</title>
<style>
body {
	margin: 0;
	background: #111;
	color: #fff;
	font-family: sans-serif;
	display: flex;
	justify-content: center;
	align-items: flex-start;
	min-height: 100vh;
	overflow: auto;
}

#toolbar {
	position: fixed;
	top: 8px;
	left: 50%;
	transform: translateX(-50%);
	background: rgba(20, 20, 20, .85);
	border: 1px solid #444;
	border-radius: 8px;
	padding: 8px 12px;
	display: flex;
	gap: 10px;
	z-index: 1000;
}

#board {
	position: relative;
	display: inline-block;
	transform-origin: top left;
	margin-top: 60px;
	user-select: none;
}

#board img {
	display: block;
	border: 2px solid #444;
}

.control {
	position: absolute;
	cursor: pointer;
}

.control>label {
	position: absolute;
	top: 100%;
	left: 50%;
	transform: translateX(-50%);
	width: max-content;
	min-width: 100%;
	text-align: center;
	font-size: 10px;
	pointer-events: none;
	color: #fff;
	background: rgba(0, 0, 0, .85);
	padding: 1px 4px;
	border-radius: 4px;
	white-space: nowrap;
}

.led-vis {
	width: 100%;
	height: 100%;
	border-radius: 50%;
	background: #320000;
	box-shadow: inset 0 0 6px #000;
}

.led-vis.on {
	background: radial-gradient(circle at 30% 30%, #f00, #a00);
	box-shadow: 0 0 12px #f00;
}

.sw-vis {
	width: 100%;
	height: 100%;
	border-radius: 8px;
	background: #333;
	border: 2px solid #777;
	position: relative;
}

.sw-vis::before {
	content: "";
	position: absolute;
	left: 12%;
	top: 55%;
	width: 76%;
	height: 40%;
	border-radius: 3px;
	background: #ccc;
	transition: .12s;
}

.sw-vis.on {
	background: #090;
}

.sw-vis.on::before {
	top: 10%;
	background: #fff;
}

.btn-vis {
	width: 100%;
	height: 100%;
	border-radius: 10px;
	background: #333;
	border: 2px solid #777;
	box-shadow: inset 0 0 6px #000;
	transition: all .06s;
}

.btn-vis.pressed {
	background: #0a0;
	border-color: #0f0;
	box-shadow: inset 0 0 12px #0f0;
}

.seg7-digit {
	position: absolute;
	width: 100%;
	height: 100%;
	transform-origin: center;
}

.seg7-digit .seg {
	position: absolute;
	background: #777;
	border-radius: 2px;
}

.seg7-digit .seg.on {
	background: #e00;
	box-shadow: 0 0 8px #f00;
}

.control.seg7>label {
	transform: translateX(-50%) skewX(10deg);
}

#vgaBox {
	position: absolute;
	border: 2px solid #444;
	background: #000;
	image-rendering: pixelated;
}

</style></head>

<body>        
  <div id="toolbar">
    <span id="status">layout.json: loading…</span>
  </div>
  <div id="board"></div>

<script>
const WS_PORT = 9001;   // hardcoded for now
const MINI_VGA = true;  // hardcoded for now

const board = document.getElementById('board');
const statusEl = document.getElementById('status');
let layout=null, ws=null;

let inSwitches = 0>>>0;
let inKeys = 0>>>0;

const ledPanel = { signal:null, bitControls:[] };
const swPanel  = { signal:null, bitControls:[] };
const keyPanel = { signal:null, bitControls:[] };
const seg7Map = new Map();
let vgaCanvas=null, vgaCtx=null, vgaImgData=null;

function setStatus(msg){ statusEl.textContent = msg; }
function clampU32(x){ return (x>>>0); }
function setBit(field, bit, on){
  field = clampU32(field);
  const mask = (1<<bit)>>>0;
  return on ? (field | mask)>>>0 : (field & (~mask))>>>0;
}

function getBit(field, bit){ return ((field>>>bit)&1)!==0; }

async function loadLayout(){
  const res = await fetch('layout.json', { cache:'no-store' });
  if(!res.ok) throw new Error('HTTP '+res.status);
  layout = await res.json();

  const img = document.createElement('img');
  img.src = layout.board.background;
  board.appendChild(img);

  img.onload = () => {
    if(layout.board.vga){
      const vb=document.createElement('canvas');
      vb.id='vgaBox';
      vb.width = layout.board.vga.width || 640;
      vb.height= layout.board.vga.height|| 480;
      vb.style.left = (layout.board.vga.left||0)+'px';
      vb.style.top  = (layout.board.vga.top||0)+'px';
      vb.style.width = (layout.board.vga.width||640)+'px';
      vb.style.height= (layout.board.vga.height||480)+'px';
      board.appendChild(vb);
      vgaCanvas=vb;
      vgaCtx=vb.getContext('2d');
      vgaCtx.imageSmoothingEnabled=false;
      vgaImgData=vgaCtx.createImageData(vb.width, vb.height);
    }

    (layout.panels||[]).forEach(p => buildPanel(p));
    setStatus('layout.json: loaded ✓');
    rescaleBoard();
    window.addEventListener('resize', rescaleBoard);
  };
}

function rescaleBoard(){
  const bg = board.querySelector('img');
  if(!bg) return;
  const w = bg.naturalWidth || bg.width;
  const h = bg.naturalHeight || bg.height;
  if(!w || !h) return;
  const scale = Math.min((window.innerWidth-40)/w, (window.innerHeight-120)/h);
  board.style.transform = `scale(${scale})`;
}

function buildPanel(p){
  if(p.type==='led') return buildLedPanel(p);
  if(p.type==='switch') return buildSwitchPanel(p);
  if(p.type==='button') return buildButtonPanel(p);
  if(p.type==='seg7') return buildSeg7Panel(p);
}

function placeControlBase(x,y,w,h,cls,labelText){
  const d=document.createElement('div');
  d.className='control '+cls;
  d.style.left=x+'px'; d.style.top=y+'px';
  d.style.width=w+'px'; d.style.height=h+'px';
  const lab=document.createElement('label'); lab.textContent=labelText||'';
  d.appendChild(lab);
  board.appendChild(d);
  return d;
}

function buildLedPanel(p){
  ledPanel.signal=p.signal; ledPanel.bitControls=[];
  for(let i=0;i<p.count;i++){
    const x=p.left + i*p.ctrlSpacing;
    const y=p.top;
    const label=(p.labels && p.labels[i]) ? p.labels[i] : `LED${p.count-1-i}`;
    const d=placeControlBase(x,y,p.ctrlWidth,p.ctrlHeight,'led',label);
    const vis=document.createElement('div'); vis.className='led-vis';
    d.insertBefore(vis, d.firstChild);
    d._vis=vis;
    ledPanel.bitControls.push(d);
  }
}

function buildSwitchPanel(p){
  swPanel.signal=p.signal; swPanel.bitControls=[];
  for(let i=0;i<p.count;i++){
    const x=p.left + i*p.ctrlSpacing;
    const y=p.top;
    const label=(p.labels && p.labels[i]) ? p.labels[i] : `SW${p.count-1-i}`;
    const d=placeControlBase(x,y,p.ctrlWidth,p.ctrlHeight,'switch',label);
    const vis=document.createElement('div'); vis.className='sw-vis';
    d.insertBefore(vis, d.firstChild);
    d._vis=vis;

    const bit=(p.count-1-i); // MSB on left
    d.addEventListener('click', () => {
      const next=!getBit(inSwitches, bit);
      inSwitches=setBit(inSwitches, bit, next);
      vis.classList.toggle('on', next);
      sendWord(20, inSwitches); 
    });

    swPanel.bitControls.push(d);
  }
}

var LastInKeys = 0;

function buildButtonPanel(p){
  keyPanel.signal=p.signal; keyPanel.bitControls=[];
  for(let i=0;i<p.count;i++){
    const x=p.left + i*p.ctrlSpacing;
    const y=p.top;
    const label=(p.labels && p.labels[i]) ? p.labels[i] : `KEY${p.count-1-i}`;
    const d=placeControlBase(x,y,p.ctrlWidth,p.ctrlHeight,'button',label);
    const vis=document.createElement('div'); vis.className='btn-vis';
    d.insertBefore(vis, d.firstChild);
    d._vis=vis;

    const bit=(p.count-1-i); // MSB on left
    
    if (!d._wired) {
      d._wired = true;
      const press=()=>{
        inKeys=setBit(inKeys, bit, true);
        vis.classList.add('pressed');
        if(LastInKeys == 0 && inKeys != 0)
        {
            sendWord(0, inKeys);
            LastInKeys = inKeys;
        }
      };
      const release=()=>{
        inKeys=setBit(inKeys, bit, false);
        vis.classList.remove('pressed');
        if(LastInKeys != 0 && inKeys == 0)
        {
            sendWord(0, inKeys);
            LastInKeys = inKeys;
        }
      };
  
      d.addEventListener('mousedown', (e)=>{ e.preventDefault(); press(); });
      window.addEventListener('mouseup', release);
      d.addEventListener('mouseleave', release);
      d.addEventListener('touchstart', (e)=>{ e.preventDefault(); press(); }, {passive:false});
      window.addEventListener('touchend', release);
      window.addEventListener('touchcancel', release);
      keyPanel.bitControls.push(d);
    }
  }
}

function buildSeg7Panel(p){
  const slant=(typeof p.slantDeg === 'number') ? p.slantDeg : -10;
  const slots=[
    {l:18,t:4,w:70,h:12},      // a
    {l:86,t:12,w:15,h:35},     // b
    {l:86,t:53,w:15,h:35},     // c
    {l:18,t:86,w:70,h:12},     // d
    {l:6,t:53,w:15,h:35},      // e
    {l:6,t:12,w:15,h:35},      // f
    {l:18,t:45,w:70,h:12},     // g
    {l:110,t:85,w:20,h:20, dot:true} // dp
  ];

  for(let i=0;i<p.digits;i++){
    const x=p.left + i*p.ctrlSpacing;
    const y=p.top;
    const label=(p.labels && p.labels[i]) ? p.labels[i] : `HEX${p.digits-1-i}`;
    const sig=(p.signals && p.signals[i]) ? p.signals[i] : null;

    const d=placeControlBase(x,y,p.ctrlWidth,p.ctrlHeight,'seg7',label);
    const digit=document.createElement('div'); digit.className='seg7-digit';
    digit.style.transform=`skewX(${slant}deg)`;
    d.insertBefore(digit, d.firstChild);

    const segEls=[];
    slots.forEach(s=>{
      const seg=document.createElement('div');
      seg.className='seg';
      seg.style.left=s.l+'%'; seg.style.top=s.t+'%';
      seg.style.width=s.w+'%'; seg.style.height=s.h+'%';
      if(s.dot) seg.style.borderRadius='50%';
      digit.appendChild(seg);
      segEls.push(seg);
    });

    d._segEls=segEls;
    if(sig) seg7Map.set(sig, d);
  }
}

function applyLedsWord(v) {
  v = v >>> 0;
    const count=ledPanel.bitControls.length;
    for(let i=0;i<count;i++){
      const bit=(count-1-i);
      const on=getBit(v, bit);
      ledPanel.bitControls[i]._vis.classList.toggle('on', on);
    }
  }

function setSeg7(el, byte){
  const segs=el._segEls; if(!segs) return;

  for(let i=0;i<8;i++){
    const bit = (byte >> i) & 1;
    const on = bit;       
    segs[i].classList.toggle('on', on);
  }
}

function applyVga(msg){
  if(!vgaCtx || !vgaImgData) return;
  const w=msg.w|0, h=msg.h|0;
  if(!w || !h || !msg.data_b64) return;

  const bytes=base64ToBytes(msg.data_b64);
  const destW=vgaCanvas.width, destH=vgaCanvas.height;
  const img=vgaImgData.data;

  // clear to black
  for(let i=0;i<img.length;i+=4){ img[i]=0; img[i+1]=0; img[i+2]=0; img[i+3]=255; }

  const maxW=Math.min(w, destW);
  const maxH=Math.min(h, destH);
  let idx=0;
  for(let y=0;y<maxH;y++){
    for(let x=0;x<maxW;x++){
      const p=bytes[idx++] ?? 0;
      const r=(p>>5)&7, g=(p>>2)&7, b=p&3;
      const R=Math.round(r*255/7);
      const G=Math.round(g*255/7);
      const B=Math.round(b*255/3);
      const o=(y*destW+x)*4;
      img[o]=R; img[o+1]=G; img[o+2]=B; img[o+3]=255;
    }
  }
  vgaCtx.putImageData(vgaImgData, 0, 0);
}

function base64ToBytes(b64){
  const bin=atob(b64);
  const out=new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) out[i]=bin.charCodeAt(i)&255;
  return out;
}

function connect(){
  const url = `ws://${location.hostname}:${WS_PORT}/board`;
  try{ ws=new WebSocket(url); }catch{ setStatus('layout.json ✓ | WS create failed'); return; }
  ws.onopen=()=>setStatus('layout.json ✓ | WS connected ✓');
  ws.binaryType = "arraybuffer";
  ws.onmessage = (evt) => {
    if (evt.data instanceof ArrayBuffer) {
      const d = new Uint8Array(evt.data);
      if (d.length !== 10 || d[0] !== 1) return;     // OUT frame
  
      const leds = d[1] | (d[2] << 8);
      applyLedsWord(leds);
  
      // Hex0..Hex5 are bytes 4..9
      // IMPORTANT: this assumes seg7Map keys are "Hex0".."Hex5"
      for (let i = 0; i < 6; i++) {
        const el = seg7Map.get(`Hex${i}`);
        if (el) setSeg7(el, d[4 + i]);
      }
      return;
    }
  };          
    
  ws.onclose=()=>setStatus('layout.json ✓ | WS disconnected');
  ws.onerror=()=>setStatus('layout.json ✓ | WS error');
  
  if (evt.data instanceof ArrayBuffer) {
    const d = new Uint8Array(evt.data);
    if (d.length !== 10 || d[0] !== 1) return;
  
    const leds = d[1] | (d[2] << 8);
    setLeds(leds);
  
    for (let i = 0; i < 6; i++) {
      setSeg7(i, d[4 + i]); 
    }
  }
}

function sendWord(wordIndex, value) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  console.trace("sendWord", wordIndex, value);

  const a = new Uint8Array(4);
  a[0] = wordIndex & 0xFF;
  a[1] = 0;
  a[2] = value & 0xFF;
  a[3] = (value >> 8) & 0xFF;

  ws.send(a);              // <-- sends BINARY
  // ws.send(a.buffer);    // also OK
}

(async function main(){
  try{
    await loadLayout();
    connect();
  }catch(e){
    setStatus('Failed: '+e.message);
    console.error(e);
  }
})();
</script>
</body>
</html>
